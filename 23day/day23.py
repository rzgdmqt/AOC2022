# part 1
(lambda np = __import__("numpy"):(lambda np = __import__("numpy"),grid = np.array(list(map(lambda o: list(o), open("d").read().strip().split("\n")))), dirs = [np.array([np.array((-1, 0)), np.array((1, 0)), np.array((0, -1)), np.array((0, 1))])],adj =  {tuple(np.array((-1, 0))): [np.array([0, -1]), np.array([0, 1]), np.array([0, 0])], tuple(np.array((1, 0))): [np.array([0, -1]), np.array([0, 1]), np.array([0, 0])], tuple(np.array((0, 1))): [np.array([-1, 0]), np.array([1, 0]), np.array([0, 0])], tuple(np.array((0, -1))):[np.array([-1, 0]), np.array([1, 0]), np.array([0, 0])]},called_positions = []: (lambda shelf = [{tuple(np.array((i, j))) : None for i, row in enumerate(grid) for j, field in enumerate(row) if field == "#"}]:any((called_positions.append({}) or any(any( False if shelf[0][elf] else ((shelf[0].update({elf: tuple(elf + dir)}) or  called_positions[0].update({tuple(np.array(elf) + dir): called_positions[0].get(tuple(np.array(elf) + dir), 0) + 1})) if all(tuple(np.array(elf) + dir + lr) not in shelf[0] for lr in adj[tuple(np.array(dir))]) else False) for dir in dirs[0]) if not all((tuple(np.array(elf) + m) not in shelf[0]) for m in [np.array([-1, -1]), np.array([-1, 0]), np.array([-1, 1]), np.array([0, 1]), np.array([1, 1]), np.array([1, 0]), np.array([1, -1]), np.array([0, -1])]) else False for elf in shelf[0]) or (shelf.append({(pos if pos is not None and called_positions[0].get(pos, 0) <= 1 else elf) : None for elf, pos in shelf[0].items()}) or shelf.pop(0) and False or dirs.append(np.roll(dirs.pop(), -1, axis=0)) or called_positions.pop(0) and False))for _ in range(10)) or (lambda mi_mj_Mi_Mj = [*grid.shape, 0, 0]: any((mi_mj_Mi_Mj.insert(0, min(mi_mj_Mi_Mj.pop(0), i)) or mi_mj_Mi_Mj.insert(1, min(mi_mj_Mi_Mj.pop(1), j)) or mi_mj_Mi_Mj.insert(2, max(mi_mj_Mi_Mj.pop(2), i)) or mi_mj_Mi_Mj.insert(3, max(mi_mj_Mi_Mj.pop(3), j)))for (i, j) in shelf[0]) or print((mi_mj_Mi_Mj[2] - mi_mj_Mi_Mj[0] + 1) * (mi_mj_Mi_Mj[3] - mi_mj_Mi_Mj[1] + 1) - len(shelf[0])))())())())()
# part 2
(lambda np = __import__("numpy"), imp=__import__("sys").setrecursionlimit(1000000):(lambda i = [0],k = [0],While=(lambda cond, cmd, state:(lambda f, *a :f(f, *a))((lambda While, cond, cmd, state: (((cmd(state) and False) or While(While, cond, cmd, state)) if cond(state) else False)), cond, cmd, state)),grid = np.array(list(map(lambda o: list(o), open("d").read().strip().split("\n")))), dirs = [np.array([np.array((-1, 0)), np.array((1, 0)), np.array((0, -1)), np.array((0, 1))])],adj =  {tuple(np.array((-1, 0))): [np.array([0, -1]), np.array([0, 1]), np.array([0, 0])], tuple(np.array((1, 0))): [np.array([0, -1]), np.array([0, 1]), np.array([0, 0])], tuple(np.array((0, 1))): [np.array([-1, 0]), np.array([1, 0]), np.array([0, 0])], tuple(np.array((0, -1))):[np.array([-1, 0]), np.array([1, 0]), np.array([0, 0])]},called_positions = [],shelf1 = [0]: (lambda shelf = [{tuple(np.array((i, j))) : None for i, row in enumerate(grid) for j, field in enumerate(row) if field == "#"}]:While(lambda s: s,lambda s: (called_positions.append({}) or any(any(False if shelf[0][elf] else ((shelf[0].update({elf: tuple(elf + dir)}) or called_positions[0].update({tuple(np.array(elf) + dir): called_positions[0].get(tuple(np.array(elf) + dir), 0) + 1})) if all(tuple(np.array(elf) + dir + lr) not in shelf[0] for lr in adj[tuple(np.array(dir))]) else False)for dir in dirs[0]) if not all((tuple(np.array(elf) + m) not in shelf[0]) for m in [np.array([-1, -1]), np.array([-1, 0]), np.array([-1, 1]), np.array([0, 1]), np.array([1, 1]), np.array([1, 0]), np.array([1, -1]), np.array([0, -1])]) else False for elf in shelf[0]) or ((shelf1.pop() and False or shelf1.append(shelf[0].copy())) or shelf.append({(pos if pos is not None and called_positions[0].get(pos, 0) <= 1 else elf) : None for elf, pos in shelf[0].items()}) or shelf.pop(0) and False or dirs.append(np.roll(dirs.pop(), -1, axis=0)) or called_positions.pop(0) and False)) or i.append(i.pop() + 1) or (print(i[0]) or k.pop() if set(shelf[0].keys()) == set(shelf1[0].keys()) else False),k))())())()