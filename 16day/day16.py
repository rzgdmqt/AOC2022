# part 1
( lambda imp, g=[], input=list( map(lambda o: o.split(" "), open("d").read().split("\n")) ), While=( lambda cond, cmd, state: (lambda f, *a: f(f, *a))( ( lambda While, cond, cmd, state: ( ((cmd(state) and False) or While(While, cond, cmd, state)) if cond(state) else False ) ), cond, cmd, state, ) ): ( lambda graph={},: any( graph.update({line[1]: {}}) or graph[line[1]].update( { "rate": int(line[4][5 : len(line[4]) - 1]), "neighbors": list(map(lambda o: o.strip(","), line[9:])), } ) for line in input ) or g.append(graph) )() or ( lambda graph=g[0], bfs=lambda u, graph: ( lambda q=[u], distance={u: 0}, seen={u}, tmp=[u]: While( lambda s: len(s) > 0, lambda s: tmp.insert(0, s.pop(0)) or (tmp.pop() and False) or any( s.append(i) or seen.add(i) or distance.update({i: distance[tmp[0]] + 1}) for i in graph[tmp[0]]["neighbors"] if i not in seen ), q, ) or distance )(): ( lambda update_graph=( lambda graph: ( lambda new_graph={}, new_nodes={"AA"}, dist={}: any( new_nodes.add(u) for u in graph if graph[u]["rate"] ) or any( dist.clear() or dist.update(bfs(u, graph)) or new_graph.update({u: {"rate": graph[u]["rate"]}}) or new_graph[u].update( {"neighbors": {v: dist[v] for v in new_nodes if v != u}} ) for u in new_nodes ) or g.append(new_graph) )() ): update_graph(g[0]) or ( lambda graph=g[-1], seen={}, m=[0]: ( lambda max_flow=lambda start, step, opened: ( lambda f, *a: f(f, *a) )( ( lambda aux, start, step, opened: ( lambda l=[]: ( seen[(start, step, opened)] if (start, step, opened) in seen else ( 0 if step >= 30 else ( any( l.append( aux( aux, v, step + d, tuple(sorted(opened)), ) ) if start in opened else l.extend( [ graph[start]["rate"] * (30 - step - 1) + aux( aux, v, step + d + 1, tuple( sorted( opened + (start,) ) ), ), aux( aux, v,step + d, tuple(sorted(opened)), ), ] ) for v, d in graph[start][ "neighbors" ].items() ) or m.append(max(l)) or (m.pop(0) and False) or seen.update( { ( start, step, tuple(sorted(opened)), ): m[-1] } ) or m[-1] ) ) ) )() ), start, step, opened, ): print( max_flow("AA", 0, ()) ) )() )() )() )())(__import__("sys").setrecursionlimit(1000000))
# part 2 - don't run it if you like your computer. I am pretty sure some bracket are missplaced and code loops forever :)
(lambda imp, g=[], input=list(map(lambda o: o.split(" "), open("b").read().split("\n"))), While=( lambda cond, cmd, state:(lambda f, *a :f(f, *a))((lambda While, cond, cmd, state: (((cmd(state) and False) or While(While, cond, cmd, state)) if cond(state) else False)), cond, cmd, state)):(lambda graph={}, :any(graph.update({line[1]: {}}) or graph[line[1]].update({"rate": int(line[4][5:len(line[4])-1]), "neighbors": list(map(lambda o: o.strip(","), line[9:]))})for line in input) or g.append(graph))() or(lambda graph=g[0],bfs=lambda u, graph:(lambda q=[u], distance={u:0}, seen={u}, tmp=[u]:While(lambda s: len(s) > 0,lambda s : tmp.insert(0, s.pop(0)) or (tmp.pop() and False) or any(s.append(i) or seen.add(i) or distance.update({i: distance[tmp[0]] + 1})for i in graph[tmp[0]]["neighbors"] if i not in seen),q) or distance)():(lambda update_graph=(lambda graph: (lambda new_graph={}, new_nodes={"AA"}, dist={}:any(new_nodes.add(u)for u in graph if graph[u]["rate"]) or any(dist.clear() or dist.update(bfs(u, graph)) or new_graph.update({u: {"rate": graph[u]["rate"]}}) or new_graph[u].update({"neighbors": {v: dist[v] for v in new_nodes if v != u}})for u in new_nodes) or g.append(new_graph) )()):update_graph(g[0]) or(lambda graph=g[-1], seen={}, m=[0]:(lambda max_flow=lambda me, elephant, step_me, step_elephant, opened:(lambda f, *a: f(f, *a))((lambda aux, me, elephant, step_me, step_elephant, opened: (lambda l=[]:(seen[(me, elephant, step_me, step_elephant, opened)] if (me, elephant, step_me, step_elephant, opened) in seen else 0 if step_me >= 30 and step_elephant >= 30 else(any(l.extend([aux(aux, me, v, step_me, step_elephant + d, tuple(sorted(opened))),aux(aux, me, elephant, step_me, step_elephant + d + 1, tuple(sorted(opened + (elephant,)))) + graph[elephant]["rate"] * (30 - step_elephant - 1)]) if v not in opened else l.append(aux(aux, me, v, step_me, step_elephant + d, tuple(sorted(opened))))for v, d in graph[elephant]["neighbors"].items())if step_me >= 30 else ((any(l.extend([aux(aux, v, elephant, step_me + d, step_elephant, tuple(sorted(opened))),aux(aux, me, elephant, step_me + d + 1, step_elephant, tuple(sorted(opened + (me,)))) + graph[me]["rate"] * (30 - step_me - 1)]) if v not in opened else l.append(aux(aux, v, elephant, step_me + d, step_elephant, tuple(sorted(opened))))for v, d in graph[me]["neighbors"].items())) if step_elephant >= 30 else (any(any( l.extend([aux(aux,v, u, step_me + d1, step_elephant + d2, tuple(sorted(opened))),aux(aux,me, u, step_me + d1 + 1, step_elephant + d2, tuple(sorted(opened + (v,)))) + graph[me]["rate"] * (30 - step_me - 1),aux(aux,v, elephant, step_me + d1, step_elephant + d2 + 1, tuple(sorted(opened + (u,)))) + graph[elephant]["rate"] * (30 - step_elephant - 1),]) if me not in opened and elephant not in opened else (l.extend([aux(aux,v, u, step_me + d1, step_elephant + d2, tuple(sorted(opened))),aux(aux,v, elephant, step_me + d1, step_elephant + d2 + 1, tuple(sorted(opened + (u,)))) + graph[elephant]["rate"] * (30 - step_elephant - 1),]) if me in opened and elephant not in opened else (l.extend([aux(aux,v, u, step_me + d1, step_elephant + d2, tuple(sorted(opened))),aux(aux,me, u, step_me + d1 + 1, step_elephant + d2, tuple(sorted(opened + (v,)))) + graph[me]["rate"] * (30 - step_me - 1),]) if elephant in opened and me not in opened else l.append(aux(aux,v, u, step_me + d1, step_elephant + d2, tuple(sorted(opened))))))for v, d1 in graph[me]["neighbors"].items()) for u, d2 in graph[elephant]["neighbors"].items()) or m.append(max(l)) or (m.pop(0) and False) or seen.update({(me, elephant, step_me, step_elephant, tuple(sorted(opened))): m[-1]}) or m[-1])))))()),me,elephant,step_me,step_elephant,opened):print(max_flow("AA", "AA", 4, 4, ())))())())())())(__import__("sys").setrecursionlimit(1000000))